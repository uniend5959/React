// 컴포넌트 재사용하기 : style를 props로 내려주면 하나의 버튼 컴포넌트를 다양하게 표현가능 
// 부모의  set함수가 사용되서 변화되면, 부모안에 있는 자식들이 전부 다시 리렌더 된다.
// 모의 set 함수를 직접적으로 prop로 받고있지 않음에도 강제로 리렌더가 되는 불필요한 리렌더를 막고 관리할수있는 게  useMemo이다. 
// 자식들이 많은 부모의 상태가 변할 경우 전부 리렌던가 일어날경우 성능이 느려지는 문제가 생길수 있다. 
// 따라서 자식들이 많은 부모가 있는 페이지 가 리렌던가 발생할때 useMEmo를사용하면 좋을듯! 
// React.memo를 사용하여 래핑된 컴포넌트는 props 변화만을 감지하여 리렌더를 경정한다 props의 변화가 없다면리렌던 되지 않느다>!

import { useState } from "react";
import Btn from "./btn";

const product ={
  color: 'green',
  fontSize : '24px',
  backgroundColor : 'yellow'
}

const Props = () => {

// 외부데이터를불러와서 색상이 변경된다 -> ui 업데이트 , state필요 
const [text, settext ]  = useState('변경전');

function changeText(){
  settext('변경후')
}

// 텍스트와 set을 모두 자식에게 전달하고 자식에서만 사용해도 자식만 리렌더링 되는경우는 없다. 
// 결국 상태의 주인인 부모가 변경되어 부모가 리렌더링 되고 자식들도 모두 자동으로 리렌더링된다(코드도 전부다 재실행됨). 
// 부모 컴포넌트에서 set고 텍스트를 사용하면 자식이 모두 리렌더링된다. 
// 자식이 부모를 리덴더링 시키고자할때는 set을 받아 부모의 상태를 변경시켜야한다. 
// momo 사용하지 않을 시 props의 변경이 발생하지 않는 컴포넌트도 리렌더링이된다 
// momo를 사용한다면 prop을 받지않거나 부모로부터 받은 props가 변경되지 않는 자식 컴포넌트는 리렌더링 되지 않는다. 
// 다만, 상태가 변할떄마다 리렌던가 발생하면 모든 코드가 전부 실행이 다시 된다. 그럴경우 성능에 큰 문제가발생한다. 
// usememo로 모든 자식을막을 수도, 컴포넌트가 아닌 함수들을 막을 수없다. 
// 그럴 경우 상태가 변해 리렌더가 일어나 ui업데이트와 모든코드 재실행되어도  페이지 로드최초 한번만 렌더(실행)될수있도록 하는 게 useEfect이다 .
// useEffect 내에서도 [] 종속을 이용하면 종속에 들어가는 상태가 변할떄 지정한 실행코드만 재실행될수있도록한다. --> 이 상태를 지켜봐!! 


// 부모컴포넌트내 상태 --> 이 상태를 지켜봐!! 변화하면 나랑자식모두 리렌더하고 함수는 다 재실행 시켜!!
// 자식은 부모책임 --> 자식이 상태를 훔쳐서 변경시켜도 부모자식 다 연대책임이여 다 재렌더링되고 재실행이여 !
// useEffect --> 그렇게 멍청하게 굴거야? 내가 지정한 코드는 부모니가 아무리 강제로 재렌더 시켜도 내가 한번만 렌더링시킬거야,, 내가 맘에든 상태역시 
// 지켜보다가 애가  변할때만 실행시킬거야! 참견마! 


// 컴포넌트에는 리스너가 붙을 수없고 실제 dom요소에 붙어야 이벤트가 작동한다. 




  return(
    <>
    <Btn fontSize={product.fontSize} color={product.color} backgroundColor={product.backgroundColor} onClick={changeText} value ={text}/>
    <Btn value={text}/>
    </>
  )
}

export default Props;